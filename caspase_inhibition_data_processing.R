#RStudio v1.4.1103 ####
#libraries ####
library(svDialogs)
library(ggplot2)
library(tidyr)
library(plyr)
library(gganimate)
library(transformr)
library(dplyr)
library(tidyverse)
library(broom)
library(magick)
library(patchwork)
library(lubridate)
library(zoo)
library(ggsignif)
library(qpcR)
library(car) 
library(FSA)
library(ggrepel)
library(gridExtra) # merge plots
library(ggdendro) # dendrograms
library(gplots) # heatmap
library(tseries) # bootstrap
library(TSclust) # cluster time series
library(dtwclust) # cluster time series with dynamic time warping
library(tibble)
library(data.table)
library(chisq.posthoc.test)


#data grabbing ####
input_directory <- choose.dir(default = getwd(), caption = "Select the folder that contains all your data (e.g. plaque_1") #prompts the user to identify directory containing the directory containing all the .csv data to be analysed
setwd(input_directory) 
dir.create(file.path("R_output/"))  #creates a directory for outputs
output_directory <- paste0(file.path(input_directory, "R_output/"))
setwd(input_directory)
temp <- list.files(path = input_directory, pattern = ".csv", recursive = T) #creates a list of all the .csv files in the input directory

#Prompts the user to enter two user inputted strings separated by a comma (with no spaces). These elements should be strings contained in the filenames  
#that are unique to that specific condition. This format has been chosen because it's the native naming convention of wells generated by a JOB in NIS-elements
condition_1 <- dlg_input(message = "Unique string in file names that identifies first condition:", Sys.info()[""])$res
condition_2 <- dlg_input(message = "Unique string in file names that identifies second condition:", Sys.info()[""])$res
condition_3 <- dlg_input(message = "Unique string in file names that identifies third condition:", Sys.info()[""])$res 
condition_4 <- dlg_input(message = "Unique string in file names that identifies fourth condition:", Sys.info()[""])$res 
control <- dlg_input(message = "Unique string in file names that identifies uninfected control cell data:", Sys.info()[""])$res 

#split the two user inputted comma separated values into two separate variables and bracket with underscores so that they match the naming convention output
#of NIS-elements
condition_1_split <- str_split_fixed(condition_1, ",", 2)
condition_2_split <- str_split_fixed(condition_2, ",", 3)
condition_3_split <- str_split_fixed(condition_3, ",", 3)
condition_4_split <- str_split_fixed(condition_4, ",", 3)
condition_1_1 <- paste0("_",condition_1_split[1],"_")
condition_1_2 <- paste0("_",condition_1_split[2],"_")
condition_2_1 <- paste0("_",condition_2_split[1],"_")
condition_2_2 <- paste0("_",condition_2_split[2],"_")
condition_2_3 <- paste0("_",condition_2_split[3],"_")
condition_3_1 <- paste0("_",condition_3_split[1],"_")
condition_3_2 <- paste0("_",condition_3_split[2],"_")
condition_3_3 <- paste0("_",condition_3_split[3],"_")
condition_4_1 <- paste0("_",condition_4_split[1],"_")
condition_4_2 <- paste0("_",condition_4_split[2],"_")
condition_4_3 <- paste0("_",condition_4_split[3],"_")
control <- paste0("_",control,"_")


#SEPARATE FILES BASED ON CONDITION/TREATMENT
#breaks up the last of input directory files based on the user inputted strings above
filenames_condition_1 <- Filter(function(x) grepl(condition_1_1, x)&!grepl("_background", x)|grepl(condition_1_2, x)&!grepl("_background", x), temp)
filenames_condition_2 <- Filter(function(x) grepl(condition_2_1, x)&!grepl("_background", x)|grepl(condition_2_2, x)&!grepl("_background", x)|grepl(condition_2_3, x)&!grepl("_background", x), temp)
filenames_condition_3 <- Filter(function(x) grepl(condition_3_1, x)&!grepl("_background", x)|grepl(condition_3_2, x)&!grepl("_background", x)|grepl(condition_3_3, x)&!grepl("_background", x), temp)
filenames_condition_4 <- Filter(function(x) grepl(condition_4_1, x)&!grepl("_background", x)|grepl(condition_4_2, x)&!grepl("_background", x)|grepl(condition_4_3, x)&!grepl("_background", x), temp)
filenames_control <- Filter(function(x) grepl(control, x)&!grepl("_background", x), temp)
filenames_background <- Filter(function(x) grepl("_background", x), temp)

#assembles data from each condition into a separate in dfs
mydata_assembled_condition_1 <- data.table:::rbindlist(lapply(filenames_condition_1, read.csv), use.names=FALSE) 
mydata_assembled_condition_2 <- data.table:::rbindlist(lapply(filenames_condition_2, read.csv), use.names=FALSE)
mydata_assembled_condition_3 <- data.table:::rbindlist(lapply(filenames_condition_3, read.csv), use.names=FALSE)
mydata_assembled_condition_4 <- data.table:::rbindlist(lapply(filenames_condition_4, read.csv), use.names=FALSE)
mydata_assembled_condition_control <- data.table:::rbindlist(lapply(filenames_control, read.csv), use.names=FALSE)
mydata_assembled_background <- data.table:::rbindlist(lapply(filenames_background, read.csv), use.names=FALSE)


df_list = mget(ls(pattern ="mydata_assembled_condition")) #put above dfs into a list for use in loop functions
condition_list <- list("Infected","QVD","Nec","QVD_Nec","uninfected")#create a list of condition names for use in loop functions

#data wrangling####
condition_data_prepper = function(x, var) {
    x %>% 
    mutate(TrackObjects_Label_100 = na_if(TrackObjects_Label, "NaN")) %>% #change cellprofiler's 'NaN' representation to R recognised 'NA'
    filter(!is.na(TrackObjects_Label)) %>% #remove NAs from the dataset
    unite("FoV_ID", Metadata_Date, Metadata_Well_ID, Metadata_FoV_ID, remove=FALSE)%>% #constructing unique_ID columns that can be used to group rows for various purposes (e.g. by cell, by FoV, etc)
    unite("unique_ID", Metadata_Date, Metadata_Well_ID,  Metadata_FoV_ID, TrackObjects_Label, remove=FALSE)%>%
    unite("FoV_Frame_ID", Metadata_Date, Metadata_Well_ID, Metadata_FoV_ID, Metadata_Frame, remove=FALSE) %>% 
    mutate(Condition = var) #set the Condition name
} 

condition_data <- map2(.x=df_list, .y=condition_list, .f=condition_data_prepper) #Loops .f over each pairwise combination of .x and .y. Output is a list of dfs


#Calculates the mean background intensity per pixel for each time point using measurements taken by masking cells in original images
background_data <- mydata_assembled_background %>% 
  dplyr:::rename(green_background=Intensity_MeanIntensity_green_background,
         red_background=Intensity_MeanIntensity_red_background) %>% 
  unite("FoV_Frame_ID", Metadata_Date, Metadata_Well_ID, Metadata_FoV_ID, Metadata_Frame, remove=FALSE) %>% 
  unite("Date_Well_ID", Metadata_Date, Metadata_Well_ID, remove=FALSE) %>% 
  dplyr:::select(FoV_Frame_ID, green_background, red_background)
  


#Stacks data for multiple conditions into a single df
#Filters any tracks that split (i.e. number of rows of data per cell != 145),
#and any tracks that don't have 145 unique time points.
#LinkType filter removes any objects recognised by LAP tracker as children of a split or mitosis  

extract_relevant_columns=function(df1, area_multiplier, intensity_multiplier) {
  temp1 <- df1 %>% dplyr:::select(Metadata_T, Metadata_Frame, unique_ID, Intensity_MeanIntensity_Red, #select all useful columns
                                  Intensity_MeanIntensity_Green, Intensity_IntegratedIntensity_Green, 
                                  Intensity_IntegratedIntensity_Red,AreaShape_Area, TrackObjects_IntegratedDistance, 
                                  AreaShape_MeanRadius, Metadata_Well_ID, Condition, AreaShape_Eccentricity, 
                                  AreaShape_Compactness, Location_Center_X, Location_Center_Y, TrackObjects_Displacement, 
                                  Metadata_Date.1, FoV_ID,TrackObjects_Lifetime, FoV_Frame_ID) %>% 
    unite("FoV_Frame_unique_ID",unique_ID, Metadata_Frame, remove=FALSE) %>% 
    group_by(FoV_Frame_unique_ID) %>% 
    dplyr:::mutate(duplicated = n()>1) %>% #creates a logical that identifies whether any given time point has more than one row with the same unique_ID
    group_by(unique_ID) %>% 
    dplyr:::filter(mean(duplicated)<0.2) %>%  #removes any unique_ID that had any time point with more than one row
    dplyr:::filter(!any((AreaShape_Area > lag(AreaShape_Area)*area_multiplier), na.rm=T))%>% #aimed at filtering out any mis-segmented and aberrantly merged cells 
    dplyr:::filter(!any((Intensity_IntegratedIntensity_Red-lag(Intensity_IntegratedIntensity_Red, k=3)>intensity_multiplier), na.rm=T)) 
}

data_merged <- map(condition_data, extract_relevant_columns, area_multiplier=20, intensity_multiplier=3)%>% #loops extract_relevant_columns over all the dfs in the condition_data list
  bind_rows() %>% #merges the list of dfs from map() into a single df
  left_join(., background_data, by="FoV_Frame_ID") %>% #joins the background data df, adding a column that contains a discrete value of background intensity for every unique intersection of time, well_ID, FoV_ID
  mutate(HPI = (Metadata_Frame*5)/60) %>% #converts frame to time in hours
  group_by(unique_ID) %>% 
  filter(Metadata_Frame<144) %>% #removes any data above frame 144
  filter(n_distinct(Metadata_Frame)>142) %>% #removes any data with 142 or fewer unique values of frame. Basically removes any duplicates that may still exist (generally there aren't any)
  mutate(normalised_sum_red=(Intensity_IntegratedIntensity_Red-(red_background*AreaShape_Area))) %>% #uses the background value added above to normalise red
  mutate(normalised_sum_green=(Intensity_IntegratedIntensity_Green-(green_background*AreaShape_Area))) %>% #uses the background value added above to normalise green
  mutate(normalised_mean_red=(Intensity_MeanIntensity_Red-red_background)) %>% #uses the background value added above to normalise red
  mutate(normalised_mean_green=(Intensity_MeanIntensity_Green-green_background)) #uses the background value added above to normalise green

data_merged_fulltimecourse <- map(condition_data, extract_relevant_columns, area_multiplier=20, intensity_multiplier=3)%>% #loops extract_relevant_columns over all the dfs in the condition_data list
  bind_rows() %>% #merges the list of dfs from map() into a single df
  left_join(., background_data, by="FoV_Frame_ID") %>% #joins the background data df, adding a column that contains a discrete value of background intensity for every unique intersection of time, well_ID, FoV_ID
  mutate(HPI = (Metadata_Frame*5)/60) %>% #converts frame to time in hours
  group_by(unique_ID) %>% 
  filter(Metadata_Frame<280) %>% 
  filter(n_distinct(Metadata_Frame)>260) %>% 
  mutate(normalised_sum_red=(Intensity_IntegratedIntensity_Red-(red_background*AreaShape_Area))) %>% #uses the background value added above to normalise red
  mutate(normalised_sum_green=(Intensity_IntegratedIntensity_Green-(green_background*AreaShape_Area))) %>% #uses the background value added above to normalise green
  mutate(normalised_mean_red=(Intensity_MeanIntensity_Red-red_background)) %>% #uses the background value added above to normalise red
  mutate(normalised_mean_green=(Intensity_MeanIntensity_Green-green_background))

unique_uninfected_cells <- data_merged %>% #creates a df showing the number of unique cells in each condition 
  filter(Condition=="uninfected") %>% 
  dplyr:::summarise(n=n_distinct(unique_ID)) %>% 
  dplyr:::summarise(nsum=sum(n))

#Calculates cutoff to identify cells as infected or uninfected based on mean and sd drawn from uninfected cells, and a user inputted multiplier
cutoff=function(df, channel, multiplier, replace = FALSE, weight=NULL) {
  median <- df %>% 
    filter(Condition=="uninfected") %>% 
    #filter(Metadata_Frame<24) %>%  #data before 2 hpi is impacted by an unexplained spike in red and green signal
    pull({{ channel }}) %>% 
    mean(, na.rm=TRUE)
  sd <- df %>% 
    filter(Condition=="uninfected") %>% 
    #filter(Metadata_Frame<24) %>%  #data before 2 hpi is impacted by an unexplained spike in red and green signal
    pull({{ channel }}) %>% 
    sd(na.rm=TRUE)
  median*multiplier+sd*multiplier
}
cutoff_score_red <- cutoff(data_merged, normalised_sum_red, 2.8) #multiplier is determined by trial and error. The lowest multiplier that yields zero uninfected control cells being identified as infected is chosen.
cutoff_score_green <- cutoff(data_merged, normalised_sum_green, 5)

#uses the cutoffs calculated by cutoff() to label cells as infected Y/N, productive Y/N
worked_filtered_infection_Scored <- data_merged %>% 
  dplyr:::group_by(unique_ID) %>% 
  dplyr:::mutate(Infected = if_else((any(normalised_sum_red>cutoff_score_red)), "YES", "NO")) %>% 
  dplyr:::mutate(productive = if_else((any(normalised_sum_green>cutoff_score_green)), "YES", "NO"))

worked_filtered_infection_Scored_fulltimecourse <- data_merged_fulltimecourse %>% 
  dplyr:::group_by(unique_ID) %>% 
  dplyr:::mutate(Infected = if_else((any(normalised_sum_red>cutoff_score_red)), "YES", "NO")) %>% 
  dplyr:::mutate(productive = if_else((any(normalised_sum_green>cutoff_score_green)), "YES", "NO"))

#Calculates the proportion of infected cells for the specified condition 
#based on the cutoff calculated above
infected_proportion <- function(df, var) {
  # Filter the data for the specific condition
  df_condition <- df %>%
    dplyr::filter(Condition == var) %>%
    group_by(unique_ID) %>%
    slice(1)
  
  # Group by unique_ID and FoV_ID, then count the number of "NO" and "YES" infected cells
  counts <- df_condition %>%
    unite("Date_Well_ID", Metadata_Date.1, Metadata_Well_ID, remove=FALSE) %>% 
    group_by(Date_Well_ID, Condition) %>%
    dplyr::summarise(no = sum(Infected == "NO", na.rm = TRUE),
                     yes = sum(Infected == "YES", na.rm = TRUE),
                     .groups = 'drop')
  
  # Calculate the proportion of infected cells
  counts <- mutate(counts, proportion = yes/(yes + no))
  
  return(counts)
}
conditions <- unique(worked_filtered_infection_Scored_fulltimecourse$Condition)
infected_score_drugs <- map_dfr(conditions, ~infected_proportion(worked_filtered_infection_Scored_fulltimecourse, .))

infected_means<- infected_score_drugs %>% 
  group_by(Condition) %>% 
  dplyr::summarise(mean=mean(proportion))

productive_proportion <- function(df, var) {
  # Filter the data for the specific condition
  df_condition <- df %>%
    dplyr::filter(Condition == var) %>%
    group_by(unique_ID) %>%
    slice(1)
  
  
  # Group by unique_ID and FoV_ID, then count the number of "NO" and "YES" infected cells
  counts <- df_condition %>%
    unite("Date_Well_ID", Metadata_Date.1, Metadata_Well_ID, remove=FALSE) %>% 
    group_by(Date_Well_ID, Condition) %>%
    dplyr::summarise(no = sum(productive == "NO", na.rm = TRUE),
                     yes = sum(productive == "YES", na.rm = TRUE),
                     .groups = 'drop')
  
  # Calculate the proportion of infected cells
  counts <- mutate(counts, proportion = yes/(yes + no))
  
  return(counts)
}
productive_score_drugs <- map_dfr(conditions, ~productive_proportion(worked_filtered_infection_Scored_fulltimecourse, .))


productive_means<- productive_score_drugs %>% 
  group_by(Condition) %>% 
  dplyr::summarise(mean=mean(proportion))

#Plot ready data ####
temp<-worked_filtered_infection_Scored %>%
  group_by(unique_ID) %>%
  filter(normalised_mean_red > cutoff_score_red) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  mutate(start_time=Metadata_Frame) %>% 
  dplyr:::select(unique_ID, start_time) #calculate infection start time for every infected cell
plot_data <- worked_filtered_infection_Scored %>% 
  group_by(unique_ID) %>% 
  filter(Condition!= "uninfected") %>% 
  filter(Infected == "YES") %>%  #exclude any cells below the red cutoff (i.e. exposed to virus but not infected)
  left_join(., temp, by="unique_ID") #join infection start time data so that every unique cell is associated with its infection start time

temp<-worked_filtered_infection_Scored_fulltimecourse %>%
  group_by(unique_ID) %>%
  filter(normalised_mean_red > cutoff_score_red) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  mutate(start_time=Metadata_Frame) %>% 
  dplyr:::select(unique_ID, start_time)
plot_data_fulltimecourse <- worked_filtered_infection_Scored_fulltimecourse %>% 
  group_by(unique_ID) %>% 
  filter(Condition!= "uninfected") %>% 
  filter(Infected == "YES") %>%  #exclude any cells below the red cutoff (i.e. exposed to virus but not infected)
  left_join(., temp, by="unique_ID") #join infection start time data so that every unique cell is associated with its infection start time

temp1<-worked_filtered_infection_Scored_fulltimecourse %>%
  group_by(unique_ID) %>%
  filter(normalised_sum_red > cutoff_score_red) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  mutate(start_time=Metadata_Frame) %>% 
  dplyr:::select(unique_ID, start_time) #calculate infection start time for every infected cell
temp2<-worked_filtered_infection_Scored_fulltimecourse %>%
  group_by(unique_ID) %>%
  filter(normalised_sum_green > cutoff_score_green) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  mutate(start_time_green=Metadata_Frame) %>% 
  dplyr:::select(unique_ID, start_time_green)


plot_data_fulltimecourse <- worked_filtered_infection_Scored_fulltimecourse %>% 
  group_by(unique_ID) %>% 
  dplyr:::mutate(remove = if_else(normalised_sum_green>50 & Metadata_Frame<10, "YES", "NO")) %>% 
  dplyr:::filter(!any(remove=="YES")) %>% 
  filter(Condition!= "uninfected") %>% 
  filter(Infected == "YES") %>%  #exclude any cells below the red cutoff (i.e. exposed to virus but not infected)
  left_join(., temp1, by="unique_ID") %>%  #join infection start time data so that every unique cell is associated with its infection start time
  left_join(., temp2, by="unique_ID")

#unique cells per condition

unique_cells <- plot_data_with_clustering %>% 
  group_by(Condition) %>% 
  summarise(count=n_distinct(unique_ID))


unique_cells_all <- worked_filtered_infection_Scored %>% 
  group_by(Condition) %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)
unique_cells_all_fulltimecourse <- worked_filtered_infection_Scored_fulltimecourse %>% 
  group_by(Condition) %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)

unique_cells_all_infected <- worked_filtered_infection_Scored_fulltimecourse %>% 
  group_by(Condition) %>% 
  dplyr:::filter(Infected=="YES") %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)
unique_cells_all_fulltimecourse_productive<- worked_filtered_infection_Scored_fulltimecourse %>% 
  group_by(Condition) %>% 
  dplyr:::filter(productive=="YES") %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)

unique_cells_all_infected_sigmoidal <- plot_data_with_sicegar %>% 
  group_by(Condition.x) %>% 
  dplyr:::filter(Infected=="YES") %>% 
  dplyr:::filter(DEC_decision_red!="double_sigmoidal") %>% 
  dplyr:::summarise(count=n_distinct(unique_ID)) %>% 
  dplyr:::rename(total_cell_count=count)
#Creates a df that summarises final timepoint red and green values
condition_compare = function(df, var_to_compare_1, var_to_compare_2) {
  temp<- df %>% 
    group_by(Condition, Metadata_Frame) %>% 
    dplyr:::mutate(min_red= min({{ var_to_compare_1 }})) %>% 
    dplyr:::mutate(max_red= max({{ var_to_compare_1 }})) %>% 
    dplyr:::mutate(Time_Mean_Red = mean({{ var_to_compare_1 }}, na.rm=TRUE))%>% 
    dplyr:::mutate(Time_Mean_Green = mean({{ var_to_compare_2 }}, na.rm=TRUE))%>% 
    dplyr:::summarise(mean_red = mean({{ var_to_compare_1 }}),
              mean_green = mean({{ var_to_compare_2 }}),
              max_red = mean({{ var_to_compare_1 }}),
              min_red = mean({{ var_to_compare_1 }}),
              sum_red = sum({{ var_to_compare_1 }}),
              sum_green = sum({{ var_to_compare_2 }}))
}


condition_compare_df <- condition_compare(plot_data, normalised_sum_red,
                                          normalised_sum_green)
condition_compare_df_fulltimecourse <- condition_compare(plot_data_with_clustering, normalised_sum_red,
                                          normalised_sum_green)


#Returns a df containing the earliest time point at which "channel1" crosses the corresponding
#threshold for every cell in "condition". Condition must be a value of Condition column in "df",
#and "channel1" must be the name of a column in "df" containing mean intensity data
#channel must be entered in quotes
infection_start_time = function(df, condition1, condition2, condition3, condition4, channel1, channel2){
  channel1 <- noquote(channel1)
  if (grepl("Red", channel1, fixed = TRUE)) {
    temp1<- df %>%
      filter(Condition=={{condition1}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_red) %>% 
      slice_min(order_by=Metadata_Frame)  
  } else {
    temp1<- df %>%
      filter(Condition=={{condition1}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_green) %>% 
      slice_min(order_by=Metadata_Frame) }
  
  if (grepl("Red", channel1, fixed = TRUE)) {
    temp2<- df %>%
      filter(Condition=={{condition2}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_red) %>% 
      slice_min(order_by=Metadata_Frame)  
  } else {
    temp2<- df %>%
      filter(Condition=={{condition2}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_green) %>% 
      slice_min(order_by=Metadata_Frame) }
  
  if (grepl("Red", channel1, fixed = TRUE)) {
    temp3<- df %>%
      filter(Condition=={{condition3}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_red) %>% 
      slice_min(order_by=Metadata_Frame)  
  } else {
    temp3<- df %>%
      filter(Condition=={{condition3}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_green) %>% 
      slice_min(order_by=Metadata_Frame) }
  if (grepl("Red", channel1, fixed = TRUE)) {
    temp4<- df %>%
      filter(Condition=={{condition4}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_red) %>% 
      slice_min(order_by=Metadata_Frame)  
  } else {
    temp4<- df %>%
      filter(Condition=={{condition4}}) %>% 
      group_by(unique_ID) %>%
      filter({{channel2}} > cutoff_score_green) %>% 
      slice_min(order_by=Metadata_Frame) }
  
  as.data.frame(qpcR:::cbind.na(temp1$HPI, temp2$HPI, temp3$HPI, temp4$HPI)) %>% 
    dplyr:::rename(condition_1 = V1, condition_2 = V2, condition_3 = V3, condition_4 = V4)
}

infection_start_time_df1 <- infection_start_time(data_merged, "Infected", "QVD", "Nec", "QVD_Nec","normalised_sum_red", normalised_mean_red)
infection_start_time_df2 <- infection_start_time(data_merged, "Infected", "QVD", "Nec", "QVD_Nec", "normalised_sum_green", normalised_mean_green)

start_time_frequency_plot_data <- worked_filtered_infection_Scored %>%
  group_by(unique_ID) %>%
  dplyr:::filter(normalised_sum_red > cutoff_score_red) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  group_by(Condition, Metadata_Frame) %>% 
  dplyr:::mutate(count = n_distinct(unique_ID)) %>% 
  dplyr:::summarise(count=first(count),
            HPI=first(HPI))
start_time_frequency_plot_data_fulltimecourse <- worked_filtered_infection_Scored_fulltimecourse %>%
  group_by(unique_ID) %>%
  dplyr:::filter(normalised_sum_red > cutoff_score_red) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  group_by(Condition, Metadata_Frame) %>% 
  dplyr:::mutate(count = n_distinct(unique_ID)) %>% 
  dplyr:::summarise(count=first(count),
            HPI=first(HPI))

start_time_frequency_plot_data_green <- worked_filtered_infection_Scored %>%
  group_by(unique_ID) %>%
  dplyr:::filter(normalised_sum_green > cutoff_score_green) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  group_by(Condition, Metadata_Frame) %>% 
  dplyr:::mutate(count = n_distinct(unique_ID)) %>% 
  dplyr:::summarise(count=first(count),
                    HPI=first(HPI))
start_time_frequency_plot_data_fulltimecourse_green <- worked_filtered_infection_Scored_fulltimecourse %>%
  group_by(unique_ID) %>%
  dplyr:::filter(normalised_sum_green > cutoff_score_green) %>% 
  slice_min(order_by=Metadata_Frame) %>% 
  group_by(Condition, Metadata_Frame) %>% 
  dplyr:::mutate(count = n_distinct(unique_ID)) %>% 
  dplyr:::summarise(count=first(count),
                    HPI=first(HPI))



#Creates a df containing infection start times tagged by condition for plotting/analysis
infection_start_time_long_red <- infection_start_time_df1 %>% 
  pivot_longer(cols=everything(), names_to="Condition", values_to="start_time") %>% 
  group_by(Condition) %>% 
  mutate(sd= sd(start_time, na.rm=TRUE),
         mean=mean(start_time, na.rm=TRUE))

infection_start_time_long_green <- infection_start_time_df2 %>% 
  pivot_longer(cols=everything(), names_to="Condition", values_to="start_time") %>% 
  group_by(Condition) %>% 
  mutate(sd= sd(start_time, na.rm=TRUE),
         mean=mean(start_time, na.rm=TRUE))

#Pull "Condition" INFECTION START TIMES FROM df AS A VECTOR
infection_start_time_vector=function(df, condition){
  df %>% 
    pull({{condition}})
}

infection_start_time_vector1= infection_start_time_vector(infection_start_time_df1, condition_1)
infection_start_time_vector2= infection_start_time_vector(infection_start_time_df1, condition_2)
infection_start_time_vector3= infection_start_time_vector(infection_start_time_df1, condition_3)
infection_start_time_vector3= infection_start_time_vector(infection_start_time_df1, condition_4)

#Generates the temporal gap between red and green passing their respective cutoffs
#in the same cell. i.e. approximate time to produce infectious progeny
RED_GREEN_LAG <- plot_data_fulltimecourse %>%
  group_by(unique_ID) %>% 
  filter(normalised_sum_red > cutoff_score_red) %>% 
  mutate(red_start = min(HPI)) %>% 
  filter(normalised_sum_green > cutoff_score_green)%>% 
  mutate(green_start = min(HPI))%>% 
  mutate(temporal_lag = ((start_time_green-start_time)*5)/60) 

#GENERATES A SUMMARY DF SHOWING TEMPORAL LAG WITH A SINGLE VALUE
#PER CELL FOR USE IN PLOTTING AND STATISTICS
RED_GREEN_LAG_stats_plots_drugs <- RED_GREEN_LAG %>% 
  group_by(Condition) %>% 
  dplyr:::mutate(mean = mean(temporal_lag),
         sd = sd(temporal_lag)) %>% 
  ungroup() %>% 
  group_by(unique_ID, Condition) %>% 
  dplyr:::summarise(mean_lag= mean(temporal_lag),
            meansd_lag = mean(sd)) %>% 
  ungroup() %>% 
  group_by(Condition) %>% 
  dplyr:::mutate(mean = mean(mean_lag))

lag_summary<- RED_GREEN_LAG %>% 
  group_by(Condition) %>% 
  summarise(mean=mean(temporal_lag))

#Endpoint data for both channels per condition.
red_summary<- plot_data %>% 
  group_by(Condition) %>%
  dplyr:::filter(Metadata_Frame=="143") %>%
  dplyr:::mutate(sd= sd(normalised_sum_red, na.rm=TRUE),
         mean=mean(normalised_sum_red, na.rm=TRUE))
green_summary <- plot_data %>% 
  group_by(Condition) %>%
  dplyr:::filter(Metadata_Frame=="143") %>%
  dplyr:::mutate(sd= sd(normalised_sum_green, na.rm=TRUE),
         mean=mean(normalised_sum_green, na.rm=TRUE))


#dplyr:::filter(Condition=="QVD") %>% 
#filter(Metadata_Frame<50) %>% 
  
#temporary plot code for comparing correlation of area with integrated intensity
lm_eqn <- function(df, y, x){
  formula = as.formula(sprintf('%s ~ %s', y, x))
  m <- lm(formula, data=df);
  # formating the values into a summary string to print out
  # ~ give some space, but equal size and comma need to be quoted
  eq <- substitute(~italic(r)^2~"="~r2*","~~p~"="~italic(pvalue), 
                   list(target = y,
                        input = x,
                        r2 = format(summary(m)$r.squared, digits = 3),
                        # getting the pvalue is painful
                        pvalue = format(summary(m)$coefficients[2,'Pr(>|t|)'], digits=3)
                   )
  )
  as.character(as.expression(eq));                 
}
early_summary <- plot_data %>% 
  filter(Metadata_Frame<70) %>%
  summarise(early_red_max=max(normalised_sum_red))

plot_data_filtered<- plot_data %>% 
  group_by(unique_ID) %>% 
  summarise(max_green=max(normalised_sum_green),
            max_red=max(normalised_sum_red),
            mean_area=mean(AreaShape_Area),
            Condition=first(Condition)) %>% 
  left_join(., early_summary, by="unique_ID") %>% 
  filter(Condition=="Infected")



p_temp<- plot_data_filtered %>% 
  ggplot(aes(x=early_red_max, y=max_green))+
  geom_point()+
  geom_text(aes(x = 10, y = 150, label = lm_eqn(plot_data_filtered, 'max_red', 'early_red_max')), size=5, parse = TRUE)+
  geom_smooth(method=lm)+
labs(x = "Max Normalised A3-GFP Integrated Intensity", y = "Max Normalised pEL-mCh Integrated Intensity",
    title = "", colour = "A3-GFP \nSum intensity \n(AU/cell)")+
  theme(legend.position = "right")

ggsave("max_green_vs_max_red_intensity_correlation_green.tiff", p_temp)
